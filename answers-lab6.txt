Q1.  Currently when the queue is full, I return an error code which I have added.  Then when I'm actually trying to send, I do a while loop checking if the returned value is 0.  This should be similar to what we do for sys_ipc_try_send because the environment will have to retry. 

Currently the transmission ring is, if it is free (the DD bit is set), then we memcpy the data into the tx_pkt_buf at the empty spot.  We then set the len and the status (so it's no longer free).  We also set the Report Status and End of Packets in the tx_array[tdt].cmd.  

We then move onto the next spot in the queue.  We loop around by taking the mod of E1000_TXD.  

Q2.  Currently I have a ring for the recieve.  I set my tail to 127 and head to 0 as there are 128 descriptors.  However in my function, I start at tail = 0 because I (+1 %128) at the beginning of the call.  

This should receive all packets in order because it then updates the tail at the end of each call.  This way we will continue to scan.  When we reach a DD that is not set, we say that our ring is empty.  Here I return an error.  Thus like in the transmit, when our returned integer is not postive, we know we are at empty and we must try again.  
Q3.  The web page served by JOS's web server says 

This file came from JOS.
Cheesy web page!.  

Q4.  It took approximately.  

3 days for Transmit
2 hour to code Receive (very similar to Transmit in terms of set up)
2 days to debug Receive
4 hours to do part Web Server
6 hours challenge.
~ 6 days.  

Challenge:

I did the MAC address challenge.  

Get MAC from EEPROM:
First I did the simple part!  Reading the MAC address out of the EEPROM.  After reading out sections 5.3.1 and a few others I decided that I would be setting the start bit then reading until the end bit.  After some experimenting it seemed like this would be giving me 4 numbers at a time.  (Which makes sense because there are 16bits of data and each number is 4 bytes... I think).  These numbers however were given in the backwards order.  Thus I made sure to set them up in the correct order when I actually set the RAL and RAH.  It took 3 different reads.    

Syscalls:
Now that I have the MAC address, I wrote 2 functions in e1000.c that get the low and the high addresses.  I feel like i probably could just have accessed the e1000 object globally?  I wrote 2 different syscalls, one returning the high and one returning the low portion of the MAC address.  This was particularly confusing because I tried doing it as one syscall that returned the whole MAC address.  However, being unfamiliar with C I was unable to do the whole memory address, dereferencing... efficiently.  Thus I gave up and made it two different syscalls.  

Reset Hardcoded lwIP:
Then I went into the .jif file and called the two syscalls.  I am attempting to then get the 2 numbers that I need for each register of the MAC address that is being set in hwaddr.  However, I've yet to perfect this.  My method of manipulating bits seems to overflow.  

Test:
Then, I would have to reset the MAC address in the GNUmakefile to reset the QEMU MAC address.  However, I am also having problems here.  Every set of numbers I've tried so far have resulted in errors where my qemu doesn't connect and run, or has some other issue where nic can't start or something.  These will be worked on later.  However, I think the basic idea of the MAC Address challenge has been dealt with (get MAC address, make syscall, reset hardcoded lwIP).    


